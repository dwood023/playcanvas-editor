<!doctype html>
<html>
<head>
    <link rel="manifest" href="manifest.json">
    <style>
        body {
            margin: 0;

            height: 100vh;
            width: 100vw;

            display: flex;
        }

        #canvas {
            width: 80%;
            height: 100%;
        }

        #sidebar {
            width: 20%;
            height: 100%;
        }

        #project-picker {
            position: relative;
            z-index: 2;
            color: white;
        }
    </style>
    <title>Template</title>
    <script src="playcanvas-stable.min.js"></script>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id='sidebar'>
        <h2>Open project</h2>
        <input id="project-picker" type='file' accept=".json" />

        <h2>Entities</h2>
        <ul id='entities'></ul>
    </div>

    <script>
        // APP
        const canvas = document.getElementById('canvas');

        // ensure canvas is resized when window changes size
        window.addEventListener('resize', () => app.resizeCanvas());

        const app = new pc.Application(canvas, {
            mouse: new pc.Mouse(canvas),
        });

        // fill the available space at full resolution
        app.setCanvasFillMode(pc.FILLMODE_NONE);
        app.setCanvasResolution(pc.RESOLUTION_AUTO);

        const picker = new pc.Picker(app, canvas.clientWidth, canvas.clientHeight);

        // TODO: Don't store cursor entity as nullable global variable like this
        // Q: What should we do instead?
        let cursor;

        const loadProject = (name) => {
            app.loadScene(name, () => {
                app.start();
                const entity_list = document.getElementById('entities');

                while (entity_list.lastChild) entity_list.lastChild.remove();

                for (let child of app.scene.root.children) {
                    const entity = document.createElement('li');
                    entity.innerText = child.name;
                    entity_list.appendChild(entity);

                    // TODO: Should re-prepare whenever active camera in scene changes
                    if ('camera' in child) {
                        picker.prepare(child.camera, app.scene);
                    }
                }

                // TODO: Don't pick an arbitary camera here
                const [camera] = app.scene.root.find(a => {
                    return a.camera;
                });

                // Create layer for editor UI entities (e.g. Cursor)
                const layer = new pc.Layer({ name: 'Editor' });

                // Add layer to scene
                app.scene.layers.pushOpaque(layer);

                // Make layer visible through camera
                camera.camera.layers = [...camera.camera.layers, layer.id];

                // Add entity to layer
                cursor = new pc.Entity({ name: 'Cursor' })

                const red = new pc.BasicMaterial();
                red.color.set(1, 0, 0);

                cursor.addComponent('model', {
                    type: 'sphere',
                    layers: [layer.id],
                    material: red,
                });

                cursor.setLocalScale(0.1, 0.1, 0.1)

                // Cursor is shown on top of all other elements
                cursor.model.material.depthTest = false;

                // Cursor is invisible until mesh is selected
                cursor.enabled = false;

                app.root.addChild(cursor);

                console.info('cursor', cursor);

            });
        };

        const project_picker = document.getElementById("project-picker");
        project_picker.onchange = (e) => {
            const [file] = e.target.files;
            loadProject(file.name);
        };

        // Hard coded project for convenient development
        loadProject('1305520.json');

        // Show cursor when mesh is clicked
        app.mouse.on(pc.EVENT_MOUSEDOWN, (e) => {
            const { x, y } = e;
            const selection = picker.getSelection(x, y);
            const [mesh] = selection;

            if (!mesh && cursor.enabled) {
                cursor.enabled = false;
                return;
            }

            const position = mesh.node.getPosition();
            cursor.enabled = true;
            cursor.setPosition(position);
        });

    </script>
</body>
</html>
